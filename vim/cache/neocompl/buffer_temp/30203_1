/*!
  @file rx_fltk_glcanvas.cpp
	
  @brief FLTKによるOpenGLウィンドウクラス
 
  @author Makoto Fujisawa 
  @date   2011-09
*/

#ifdef _DEBUG
#pragma comment(lib, "rx_modeld.lib")
#else
#pragma comment(lib, "rx_model.lib")
#endif

//#ifdef _DEBUG
//#pragma comment (lib, "libjpegd.lib")
//#pragma comment (lib, "libpngd.lib")
//#pragma comment (lib, "zlibd.lib")
//#else
//#pragma comment (lib, "libjpeg.lib")
//#pragma comment (lib, "libpng.lib")
//#pragma comment (lib, "zlib.lib")
//#endif

//-----------------------------------------------------------------------------
// インクルードファイル
//-----------------------------------------------------------------------------
#include "rx_fltk_glcanvas.h"
#include "rx_fltk_window.h"

// テクスチャ
-#include "rx_texture.h"

// 画像
//#include "rx_jpeg.h"
#include "rx_png.h"
#include "rx_bitmap.h"

// 設定ファイル
#include "rx_atom_ini.h"


//-----------------------------------------------------------------------------
// 定数・変数
//-----------------------------------------------------------------------------
const GLfloat RX_LIGHT0_POS[4] = {  2.0f, 4.0f, 1.0f, 0.0f };
const GLfloat RX_LIGHT1_POS[4] = { -1.0f, -10.0f, -1.0f, 0.0f };

const GLfloat RX_LIGHT_AMBI[4] = { 0.1f, 0.1f, 0.1f, 1.0f };
const GLfloat RX_LIGHT_DIFF[4] = { 0.9f, 0.9f, 0.9f, 1.0f };
const GLfloat RX_LIGHT_SPEC[4] = { 0.2f, 0.2f, 0.2f, 1.0f };

const GLfloat RX_GREEN[] = { 0.1f, 1.0f, 0.1f, 1.0f };
const GLfloat RX_RED[]   = { 1.0f, 0.1f, 0.1f, 1.0f };
const GLfloat RX_BLUE[]  = { 0.1f, 0.1f, 1.0f, 1.0f };
const GLfloat RX_WHITE[] = { 1.0f, 1.0f, 1.0f, 1.0f };

const GLfloat RX_FOV = 45.0f;

extern rxINI *g_pINI;	//!< 設定ファイル

double g_fTBTran[3] = {0, 0, -5};	//!< 視点移動用トラックボールの平行移動量(設定ファイルへの保存用)
double g_fTBQuat[4] = {1, 0, 0, 0};	//!< 視点移動用トラックボールの回転量(設定ファイルへの保存用)

extern vector<string> g_vDefaultFiles;	//!< デフォルト読み込みファイル


//-----------------------------------------------------------------------------
// rxFlWindowクラスの実装
//-----------------------------------------------------------------------------

//! コンストラクタ
rxFlGLWindow::rxFlGLWindow(int x_, int y_, int w_, int h_, const char* l, void *parent)
	: Fl_Gl_Window(x_, y_, w_, h_, l), m_iWinW(w_), m_iWinH(h_)
{
	m_pParent = (rxFlWindow*)parent;
	m_bAnimation = false;
	resizable(this);
	end();

	// 描画フラグ
	m_iDraw = 0;
	m_iDraw |= RX_IDD_FACE;

	// 回転
	m_fRot[0] = 0.0;
	m_fRot[1] = 1.0;
	m_fRot[2] = 0.0;
	m_fRot[3] = 0.0;
	m_bRotDrag = false;

	m_iRotInertia = 0;


	// デフォルトファイル読み込み
	if(g_vDefaultFiles.empty()){
		OpenFile("bunny.wrl");
	}
	else{
		OpenFile(g_vDefaultFiles[0]);
	}

	cout << "bunny : " << RXFile::Exist("bunny.wrl") << endl;
	vector<string> fpaths;
	RXFile::Search(".", fpaths, 1);
	vector<string>::iterator it = fpaths.begin();
	for(; it != fpaths.end(); ++it){
		cout << *it << endl;
	}
	
	// 設定ファイル
	if(g_pINI){
		g_pINI->Set("gl", "draw", &m_iDraw, m_iDraw);
		g_pINI->Set("gl", "inertia", &m_iRotInertia, m_iRotInertia);

		g_pINI->Set("trackball", "tx",  &g_fTBTran[0],  0.0);
		g_pINI->Set("trackball", "ty",  &g_fTBTran[1],  0.0);
		g_pINI->Set("trackball", "tz",  &g_fTBTran[2], -5.0);
		g_pINI->Set("trackball", "q0",  &g_fTBQuat[0],  1.0);
		g_pINI->Set("trackball", "q1",  &g_fTBQuat[1],  0.0);
		g_pINI->Set("trackball", "q2",  &g_fTBQuat[2],  0.0);
		g_pINI->Set("trackball", "q3",  &g_fTBQuat[3],  0.0);
	}
}

//! デストラクタ
rxFlGLWindow::‾rxFlGLWindow()
{
}


/*! 
 * GLの初期化関数
 */
void rxFlGLWindow::InitGL(void)
{
	// MARK:InitGL
	m_fBGColor[0] = 1.0; m_fBGColor[1] = 1.0; m_fBGColor[2] = 1.0;
	m_iMouseButton = -1;

	cout << "OpenGL Ver. " << glGetString(GL_VERSION) << endl;

	glClearColor((GLfloat)m_fBGColor[0], (GLfloat)m_fBGColor[1], (GLfloat)m_fBGColor[2], 1.0f);

	glEnable(GL_DEPTH_TEST);
	glDisable(GL_CULL_FACE);
	glEnable(GL_AUTO_NORMAL);
	glEnable(GL_NORMALIZE);

	// 光源設定
	glLightfv(GL_LIGHT0, GL_AMBIENT,  RX_LIGHT_AMBI);
	glLightfv(GL_LIGHT0, GL_DIFFUSE,  RX_LIGHT_DIFF);
	glLightfv(GL_LIGHT0, GL_SPECULAR, RX_LIGHT_SPEC);
	glLightfv(GL_LIGHT0, GL_POSITION, RX_LIGHT0_POS);

	glLightfv(GL_LIGHT1, GL_AMBIENT,  RX_LIGHT_AMBI);
	glLightfv(GL_LIGHT1, GL_DIFFUSE,  RX_LIGHT_DIFF);
	glLightfv(GL_LIGHT1, GL_SPECULAR, RX_LIGHT_SPEC);
	glLightfv(GL_LIGHT1, GL_POSITION, RX_LIGHT1_POS);

	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHTING);

	glShadeModel(GL_SMOOTH);

	glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
	glEnable(GL_COLOR_MATERIAL);

	// トラックボール初期姿勢
	m_tbView.SetTranslation(g_fTBTran[0], g_fTBTran[1]);
	m_tbView.SetScaling(g_fTBTran[2]);
	m_tbView.SetQuaternion(g_fTBQuat);
}

/*!
 * 視点の初期化
 */
void rxFlGLWindow::InitView(void)
{
	double q[4] = {1, 0, 0, 0};
	m_tbView.SetQuaternion(q);
	m_tbView.SetScaling(-5.0);
	m_tbView.SetTranslation(0.0, 0.0);
}

/*! 
 * リサイズイベント処理関数
 * @param[in] w キャンバス幅(ピクセル数)
 * @param[in] h キャンバス高さ(ピクセル数)
 */
void rxFlGLWindow::Resize(int w, int h)
{
	m_iWinW = w;
	m_iWinH = h;

	glViewport(0, 0, w, h);
	m_tbView.SetRegion(w, h);

	// 透視変換行列の設定
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	Projection(w, h);

	// モデルビュー変換行列の設定
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
}

/*!
 * 透視投影変換
 */
void rxFlGLWindow::Projection(int w, int h)
{
	gluPerspective(RX_FOV, (float)w/(float)h, 0.2f, 1000.0f);
	//glOrtho(-1, 1, -1, 1, -1, 1);
}

/*!
 * xyz軸描画(x軸:赤,y軸:緑,z軸:青)
 * @param[in] len 軸の長さ
 */
inline int DrawAxis(double len, double line_width = 5.0)
{
	glLineWidth((GLfloat)line_width);

	// x軸
	glColor3f(1.0, 0.0, 0.0);
	glBegin(GL_LINES);
	glVertex3d(0.0, 0.0, 0.0);
	glVertex3d(len, 0.0, 0.0);
	glEnd();

	// y軸
	glColor3f(0.0, 1.0, 0.0);
	glBegin(GL_LINES);
	glVertex3d(0.0, 0.0, 0.0);
	glVertex3d(0.0, len, 0.0);
	glEnd();

	// z軸
	glColor3f(0.0, 0.0, 1.0);
	glBegin(GL_LINES);
	glVertex3d(0.0, 0.0, 0.0);
	glVertex3d(0.0, 0.0, len);
	glEnd();

	return 1;
}


void rxFlGLWindow::RenderScene(void)
{
	glPushMatrix();

	glEnable(GL_LIGHTING);
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	// オブジェクト描画
	glColor3f(0.0, 0.0, 1.0);
	if(!m_vPolys.empty()){
		vector<rxPolygons>::iterator itr = m_vPolys.begin();
		for(; itr != m_vPolys.end(); ++itr){
			itr->Draw(m_iDraw);
		}
	}

	// 軸描画
	if(m_iDraw & RX_IDD_AXIS){
		glDisable(GL_LIGHTING);
		DrawAxis(3.0, 3.0);
	}

	glPopMatrix();
}


/*!
 * 再描画イベント処理関数
 */
void rxFlGLWindow::Display(void)
{
	// MARK:Display
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glPushMatrix();

	m_tbView.Apply();	// マウスによる回転・平行移動の適用

	RenderScene();

	glPopMatrix();

	//swap_buffers();
}


/*!
 * マウスイベント処理関数
 * @param[in] button マウスボタン(GLUT_LEFT_BUTTON,GLUT_MIDDLE_BUTTON,GLUT_RIGHT_BUTTON)
 * @param[in] state マウスボタンの状態(GLUT_UP, GLUT_DOWN)
 * @param[in] x,y マウス座標(スクリーン座標系)
 */
void rxFlGLWindow::Mouse(int button, int state, int x, int y)
{
	if(x < 0 || y < 0) return;

	make_current();
	m_iKeyMod = (Fl::event_state(FL_SHIFT) ? 2 : (Fl::event_state(FL_CTRL) ? 3 : 1));
	
	if(button == FL_LEFT_MOUSE){
		if(state){	// ボタンダウン
			m_tbView.Start(x, y, m_iKeyMod);
		}
		else{		// ボタンアップ
			if(m_iRotInertia){
				m_tbView.GetLastRotation(m_fRot[0], m_fRot[1], m_fRot[2], m_fRot[3]);
				SwitchIdle(1);
			}

			m_tbView.Stop(x, y);

			// 設定ファイルへの保存用にトラックボール姿勢を確保
			m_tbView.GetTranslation(g_fTBTran);
			m_tbView.GetScaling(g_fTBTran[2]);
			m_tbView.GetQuaternion(g_fTBQuat);
		}
	}
	else if(button == FL_MIDDLE_MOUSE){
	}
	else if(button == FL_RIGHT_MOUSE){
	}
	redraw();
}

/*!
 * モーションイベント処理関数(マウスボタンを押したままドラッグ)
 * @param[in] x,y マウス座標(スクリーン座標系)
 */
void rxFlGLWindow::Motion(int x, int y)
{
	if(x < 0 || y < 0) return;

	make_current();
	m_tbView.Motion(x, y);
	redraw();
}

/*!
 * モーションイベント処理関数(マウスボタンを押さない移動)
 * @param[in] x,y マウス座標(スクリーン座標系)
 */
void rxFlGLWindow::PassiveMotion(int x, int y)
{
	if(x < 0 || y < 0) return;

	//make_current();
	//redraw();
}

/*!
 * キーボードイベント処理関数
 * @param[in] key キーの種類
 * @param[in] x,y キーが押されたときのマウス座標(スクリーン座標系)
 */
void rxFlGLWindow::Keyboard(int key, int x, int y)
{
	make_current();

	// 修飾キー
	m_iKeyMod = (Fl::event_state(FL_SHIFT) ? 2 : (Fl::event_state(FL_CTRL) ? 3 : 1));

	switch(key){
	case 'g':	// OpenGLキャンパスをウィンドウ内でフルスクリーンにする
		SwitchFullScreen();
		break;

	default:
		break;
	}

	redraw();
}

/*!
 * 回転を加える
 * @param[in] ang 回転角
 * @param[in] x,y,z 回転軸
 * @param[in] drag 1で回転，0で回転停止
 */
void rxFlGLWindow::SetRotation(double ang, double x, double y, double z, int drag)
{
	if(drag){
		m_fRot[0] = 10.0*ang;
		m_fRot[1] = x;
		m_fRot[2] = y;
		m_fRot[3] = z;
		SwitchIdle(1);
	}
	else{
		if(!m_iRotInertia){
			SwitchIdle(0);
		}
	}

	redraw();
}


/*!
 * アイドルコールバック関数
 * @param[in] x ユーザ定義変数
 */
void rxFlGLWindow::OnIdle_s(void* x)
{
	((rxFlGLWindow*)x)->Idle();
}
void rxFlGLWindow::Idle(void)
{
	make_current();
	m_tbView.AddRotation(m_fRot[0], m_fRot[1], m_fRot[2], m_fRot[3]);
	redraw();
}

/*!
 * タイマーコールバック関数
 * @param[in] x ユーザ定義変数
 */
void rxFlGLWindow::OnTimer_s(void* x)
{
	((rxFlGLWindow*)x)->Timer();
}
void rxFlGLWindow::Timer(void)
{
	Idle();
	if(m_bAnimation){
		Fl::repeat_timeout(0.033, OnTimer_s, this);
	}
}


/*!
 * アイドル関数のON/OFF
 * @param[in] on trueでON, falseでOFF
 */
void rxFlGLWindow::SwitchIdle(int on)
{
	m_bAnimation = (on == -1) ? !m_bAnimation : (on ? true : false);
	if(m_bAnimation){
		//Fl::add_timeout(0.033, OnTimer_s, this);
		if(!Fl::has_idle(rxFlGLWindow::OnIdle_s, this)){
			Fl::add_idle(rxFlGLWindow::OnIdle_s, this);
		}
	}
	else{
		if(Fl::has_idle(rxFlGLWindow::OnIdle_s, this)){
			Fl::remove_idle(rxFlGLWindow::OnIdle_s, this);
		}
	}
}


/*!
 * フルスクリーン/ウィンドウ表示の切り替え
 */
void rxFlGLWindow::SwitchFullScreen(void)
{
	static int is_fullscreen = 0;
	static int pos0[2] = { 0, 0 };
	static int win0[2] = { 500, 500 };
	if(is_fullscreen){
		fullscreen_off(pos0[0], pos0[1], win0[0], win0[1]);
		is_fullscreen = 0;
	}
	else{
		pos0[0] = x();
		pos0[1] = y();
		win0[0] = w();
		win0[1] = h();
		fullscreen();
		is_fullscreen = 1;
	}
}

/*!
 * パスからファイル名を取り除いたパスを抽出
 * @param[in] path パス
 * @return フォルダパス
 */
inline string GetFolderPath(const string &path)
{
    size_t pos1;
 
    pos1 = path.rfind('¥¥');
    if(pos1 != string::npos){
        return path.substr(0, pos1+1);
        
    }
 
    pos1 = path.rfind('/');
    if(pos1 != string::npos){
        return path.substr(0, pos1+1);
    }
 
    return "";
}

/*!
 * ファイル読み込み
 * @param[in] fn ファイルパス
 */
void rxFlGLWindow::OpenFile(const string &fn)
{
	rxPolygons poly;
	RxModel::Read(fn, poly);

	if(poly.open){
		// テクスチャ読み込み
		if(!poly.materials.empty()){
			string parent_path = GetFolderPath(fn);	// ファイルフォルダ
			rxMTL::iterator iter = poly.materials.begin();
			for(; iter != poly.materials.end(); ++iter){
				if(iter->second.tex_file.empty()) continue;

				//iter->second.tex_file = parent_path+iter->second.tex_file;	// テクスチャファイル名にフォルダを付加
				std::cout << iter->first << " : " << iter->second.tex_file << endl;

				LoadGLTexture(iter->second.tex_file, iter->second.tex_name, false, false);

			}
		}

		if(m_vPolys.empty()){
			m_vPolys.push_back(poly);
		}
		else{
			m_vPolys[0] = poly;
		}
	}
	redraw();
}

/*!
 * ファイル書き込み
 * @param[in] fn ファイルパス
 */
void rxFlGLWindow::SaveFile(const string &fn)
{
	if(!m_vPolys.empty()){
		RxModel::Save(fn, m_vPolys[0]);
	}
}

/*!
 * 読み込んだオブジェクトのクリア
 */
void rxFlGLWindow::ClearObject(void)
{
	m_vPolys.clear();
	redraw();
}


/*!
 * 現在の画面描画を画像ファイルとして保存
 * @param[in] fn ファイルパス
 */
void rxFlGLWindow::SaveDisplay(const string &fn)
{
	static int count = 0;
	//string fn = CreateFileName("view_", ".png", count, 5);

	int w_ = w();
	int h_ = h();
	int c_ = 4;

	make_current();
	unsigned char* data = new unsigned char[w_*h_*c_];

	glReadPixels(0, 0, w_, h_, GL_RGBA, GL_UNSIGNED_BYTE, data);

	// 上下反転
	int stride = w_*c_;
	for(int j = 0; j < h_/2; ++j){
		for(int i = 0; i < stride; ++i){
			unsigned char tmp = data[j*stride+i];
			data[j*stride+i] = data[(h_-j-1)*stride+i];
			data[(h_-j-1)*stride+i] = tmp;
		}
	}

	string ext = GetExtension(fn);
	if(ext == "bmp"){
		WriteBitmapFile(fn, data, w_, h_, c_, RX_BMP_WINDOWS_V3);
		cout << "saved the screen image to " << fn << endl;
		count++;
	}
	else if(ext == "png"){
		WritePngFile(fn, data, w_, h_, c_);
		cout << "saved the screen image to " << fn << endl;
		count++;
	}

	delete [] data;
}


/*!
 * イベントハンドラ
 * @param[in] ev イベントID
 */
int rxFlGLWindow::handle(int e)
{
	switch(e){
	case FL_DND_ENTER:
	case FL_DND_RELEASE:
	case FL_DND_LEAVE:
	case FL_DND_DRAG:
	case FL_PASTE:
		// DnDBoxにペースト処理を渡すために，
		// これらのイベントが来たときはFl_Gl_Window::handleに処理を渡さない．
		return 1;

	default:
		break;
	}

	return Fl_Gl_Window::handle(e);
}


/*!
 * Fl_Menu_Barのコールバック関数 - Draw
 * @param[in] widget ウィジットの親クラスオブジェクト
 * @param[in] x ユーザ定義変数
 */
void rxFlGLWindow::OnMenuDraw_s(Fl_Widget *widget, void* x)
{
	Fl_Menu_Bar *menubar = (Fl_Menu_Bar*)widget;
	char picked[80];
	menubar->item_pathname(picked, sizeof(picked)-1);	// メニュー名

	string label = picked;
	string menu_name = "Draw/";
	label = label.substr(menu_name.size(), string::npos);

	((rxFlGLWindow*)x)->OnMenuDraw(1.0, label);
}
void rxFlGLWindow::OnMenuDraw(double val, string label)
{
	int idx = 0;
	while(label.find(RX_DRAW_STR[idx*2]) != 0) idx++;

	int flag = (0x01 << idx);
	m_iDraw ^= flag;
		
	m_pParent->UpdateMenuState();
	redraw();
}
