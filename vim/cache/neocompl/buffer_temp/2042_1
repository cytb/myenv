{-# LANGUAGE OverloadedStrings, PackageImports #-}
module Othello.Renderer.GLFW(play) where

-- import Graphics.UI.GLFW as GLFW
-- import qualified "GLFW-b" Graphics.UI.GLFW as GLFWb
-- import Graphics.GL as RawGL
import qualified "GLFW" Graphics.UI.GLFW as GLFW
import qualified Graphics.Rendering.OpenGL as GL
import qualified Graphics.Rendering.FTGL as FTGL
import qualified Codec.Picture.Repa as Repa
import           Data.Array.Repa (Z(Z), (:.) (..))
import qualified Data.Array.Repa as Repa
import qualified Data.Array.Repa.Repr.ForeignPtr as RepaF
import Foreign.Marshal.Alloc(alloca)
import Foreign.ForeignPtr(withForeignPtr)
import Graphics.Rendering.OpenGL (($=))
import Control.Monad (forM_, mapM_, replicateM_, when, liftM, unless)
import Data.Maybe(Maybe(..),maybe)
import Data.IORef(newIORef, readIORef, atomicModifyIORef, atomicWriteIORef)
import Unsafe.Coerce(unsafeCoerce)
import Data.List(intercalate)

import Othello.Core
import Othello.Game
import qualified Debug.Trace as Debug

loadFont fontPath fontSize renderResolution =  do
  font <- FTGL.createPolygonFont fontPath
  FTGL.setFontFaceSize font fontSize renderResolution
  return font

{-# INLINE gsizei #-}
gsizei :: Int -> GL.GLsizei
gsizei = unsafeCoerce

loadTextures :: [FilePath] -> IO [GL.TextureObject]
loadTextures = mapM loadTexture 

loadTexture :: FilePath -> IO GL.TextureObject
loadTexture filePath = do
  image <- either error id <$> Repa.readImageRGBA filePath
  let content = Repa.delay . Repa.imgData $ image
      (Z :. width :. height :. _) = Repa.extent content
      size = GL.TextureSize2D (gsizei width) (gsizei height)
      pix  = GL.PixelData GL.RGBA GL.UnsignedInt8888

  [texture] <- GL.genObjectNames 1
  GL.textureBinding GL.Texture3D $= Just texture

  fptr <- liftM RepaF.toForeignPtr $ Repa.computeP $ content

  withForeignPtr fptr $
    GL.texImage2D GL.Texture2D GL.NoProxy 0 GL.RGBA8 size 0 . pix

  return texture

play :: Play
play looper initState = do
  -- main resolution
  let (xres,yres) = windowSize initState
      (near,far)  = (-2000,2000) :: (Float,Float)
      glfwWinSize = GL.Size (fromIntegral xres) (fromIntegral yres)

  font <- loadFont "MTLmr3m.ttf" (xres `div` 64) xres

  let textOut str = FTGL.renderFont font str (FTGL.All)

  GLFW.initialize

  -- enable antialiasing (especially for fonts)
  GLFW.openWindowHint GLFW.FSAASamples 4

  let params = [
          GLFW.DisplayAlphaBits 8
        , GLFW.DisplayDepthBits 16
        ]
    in GLFW.openWindow glfwWinSize params GLFW.Window
  GLFW.windowTitle $= "Hothello"

  -- multisample is enabled as opengl default.
  -- GL.multisample $= GL.Enabled

  -- disable auto polling in swapBuffers
  GLFW.disableSpecial GLFW.AutoPollEvent

  GL.lineSmooth $= GL.Enabled
  -- GL.blend      $= GL.Enabled
  -- GL.blendFunc  $= (GL.SrcAlpha, GL.OneMinusSrcAlpha)
  GL.clearColor $= GL.Color4 0 0 0 0
  GL.cullFace   $= Just GL.Back
  GL.frontFace  $= GL.CCW


  -- l <- readIORef lines
  GL.depthFunc  $= Just GL.Lequal
  -- GL.depthMask  $= GL.Enabled
  GL.texture GL.Texture2D $= GL.Enabled

  -- state vars
  gameState <- newIORef initState
  dirty <- newIORef True
  quit  <- newIORef False
  posS  <- newIORef $ Just (0,0)
  posP  <- newIORef (0,0)
  posR  <- newIORef (0,0)
  sizeW <- newIORef (0,0)
  count <- newIORef 0

  let square :: Float -> [(Float,Float,Float)]
      square m   = [(-m,-m,0),(m,-m,0),(m,m,0),(-m,m,0)]

      boardWidth, inner, sz, st :: Float
      boardWidth = fromIntegral (min yres xres)
      inner      = (boardWidth/2) - (0.03 * boardWidth)
      sz         = fromIntegral . size . table $ initState
      st         = 2 * inner / sz

      transXY m (x,y,z) = (x + m, y + m, z)
      withZ   z (x,y,_) = (x,y,z)
      -- uncurry3 f (a,b,c) = f a b c
      color3     (a,b,c) = GL.color     (GL.Color3  a b c :: GL.Color3  GL.GLfloat)
      vertex3    (a,b,c) = GL.vertex    (GL.Vertex3 a b c :: GL.Vertex3 GL.GLfloat)
      normal3    (a,b,c) = GL.normal    (GL.Normal3 a b c :: GL.Normal3 GL.GLfloat)
      translate3 (a,b,c) = GL.translate (GL.Vector3 a b c :: GL.Vector3 GL.GLfloat)
      rotate3 d  (a,b,c) = GL.rotate d  (GL.Vector3 a b c :: GL.Vector3 GL.GLfloat)

      circleVertices r = [ (r*cos t,r*sin t,0) | t <- [0,0.2..0.2 + (2*pi)] ]

  -- rotated xy plane normal
  let normalizePoint2d rt@(rtx,rty) (mx,my) =
        let rad n      = pi * (fromIntegral n / 180)
            rotateX r (x,y,z) = (x, y * cos r' - z * sin r', y * sin r' + x * cos r' )
              where r' = rad r
            rotateY r (x,y,z) = (x * cos r' + z * sin r',y, - x * sin r' + z * cos r')
              where r' = rad r
            normalRtXY (rtx',rty') = rotateY rty' . rotateX rtx' $ (0,0,1)
            dotProduct (x,y,z) (x',y',z') = (x*x' + y*y' + z*z')
            lengthVec  a = sqrt $ dotProduct a a
            unitVec    v@(x,y,z) = (x / lengthVec v, y / lengthVec v, z / lengthVec v)

            epsiron     = 0.0001
            (nx,ny,nz)  = normalRtXY rt
            mpos2d      = (mx, my, 0)
            inFace      = dotProduct (nx,ny,nz) mpos2d            < epsiron -- == 0
            orthoFace   = dotProduct (nx,ny,nz) (unitVec mpos2d)  < epsiron-- == 0
            mz          = - (mx * nx + my * ny) / nz
            (mx',my',_) = rotateX (-rtx) . rotateY (-rty) $ (mx,my,mz)
        in if (not inFace && not orthoFace ) then Just (mx',my') else Nothing

      normWinPos sz mPos =
        let (rw,rh) = tmap fromIntegral sz
            (rx,ry) = tmap fromIntegral (xres,yres)
            scale_  = max (rx/rw) (ry/rh)
            (mx,my) = tmap fromIntegral mPos

        in tmap (* scale_) (mx-(rw/2),(rh/2)-my) -- normalize

      stonePos (x,y) | abs x > inner = Nothing
                     | abs y > inner = Nothing
                     | otherwise     = Just . tmap (floor . (/ st) . (+ inner)) $ (x,-y)

      pointToStonePos sizeW_ rt mpos = do
          Just $! (Debug.trace (concat [
            "point2StonePos1 [ sizeW_ = ", show sizeW_, ", rt = " , show rt, ", mpos = ", show mpos,"]"]) ())
          n <- normalizePoint2d rt $ normWinPos sizeW_ mpos
          Just $! (Debug.trace (concat [
            "point2StonePos2 [ sizeW_ = ", show sizeW_, ", rt = " , show rt, ", mpos = ", show mpos,", n = ", show n , "]"]) ())
          stonePos n


  -- onResize (and onOpen)
  GLFW.windowSizeCallback $= \ size@(GL.Size w h) -> do
    -- compute target scale for viewport to fit direction and size appropriately.
    let (rw,rh) = tmap fromIntegral (w,h)       :: (Float,Float)
        (rx,ry) = tmap fromIntegral (xres,yres)
        ar      = (ry*rw)/(rx*rh)
        (sx,sy) = if ar > 1 then (ar,1) else (1,1/ar)
        (fw,fh) = tmap realToFrac ((sx*rx/2),(sy*ry/2))
        (zn,zf) = tmap realToFrac (near,far) -- (/ scale_)) (near,far)

    atomicWriteIORef sizeW (w,h)

    GL.lineSmooth $= GL.Enabled
    -- GL.blend      $= GL.Enabled
    -- GL.blendFunc  $= (GL.SrcAlpha, GL.OneMinusSrcAlpha)
    GL.clearColor $= GL.Color4 0 0 0 0
    -- GL.cullFace   $= Just GL.Back
    -- GL.frontFace  $= GL.CCW

    -- l <- readIORef lines
    GL.depthFunc  $= Just GL.Lequal
    -- GL.depthMask  $= GL.Enabled
    GL.texture GL.Texture2D $= GL.Enabled


    GL.viewport   $= (GL.Position 0 0, size)
    GL.matrixMode $=  GL.Projection
    GL.loadIdentity
    GL.ortho (-fw) fw (-fh) fh zn zf -- centering
    -- GL.frustum (-fw) fw (-fh) fh zn zf -- zn zf -- centering
    -- GL.perspective 150 1 10 10000
    -- frustum (-fw) fw (-fh) fh zn zf -- zn zf -- centering


    putStrLn $ show [fw,fh,zn,zf]

    GL.matrixMode $= GL.Modelview 0
    GL.loadIdentity

  GLFW.windowRefreshCallback $= atomicWriteIORef dirty True
  GLFW.windowCloseCallback   $= do
    atomicWriteIORef quit True
    return True

  -- use key callback to track whether ESC or Q is pressed
  GLFW.keyCallback $= \key st -> do
    when (key == GLFW.SpecialKey GLFW.ESC && st == GLFW.Press) $ do
      atomicWriteIORef quit True

    when (key == GLFW.CharKey 'Q' && st == GLFW.Press) $ do
      atomicWriteIORef quit True

    when (key == GLFW.CharKey 'R' && st == GLFW.Press) $ do
      atomicWriteIORef posR (0,0)
      atomicWriteIORef dirty True

  let renderStones :: Float -> Float -> GameState -> IO ()
      renderStones radius thickness s_ =
        GL.preservingMatrix . forM_ (stones . table $ s_) $ \(color, (sx,sy)) -> do
          let vsBase   = circleVertices radius
              vsTop    = map (withZ ( thickness/2)) vsBase
              sqvs (x1:[]) (y1:[])       = return ()
              sqvs (x1:x2:xs) (y1:y2:ys) = mapM_ vertex3 [x1,y1,y2,x2] >>
                                           sqvs (x2:xs) (y2:ys)

              norm' x    = (fromIntegral x + 0.5) * st
              norm (x,y) = (norm' x - inner, inner - norm' y, 0)
              colors x   = (if x == White then id else reverse) [(1,1,1),(0,0,0)]

          GL.preservingMatrix $ do
            translate3 $ norm (sx,sy)
            forM_ (colors color) $ \faceColor -> do
              color3 faceColor
              GL.renderPrimitive GL.Polygon $ mapM_ vertex3 vsTop
              GL.renderPrimitive GL.Quads   $ sqvs vsTop vsBase
              rotate3 180 (1,1,0)


  let withTexture texType ioAction = do
        GL.texture texType $= GL.Enabled
        ioAction
        GL.texture texType $= GL.Disabled

  let render = do
        state_ <- readIORef gameState
        count_ <- readIORef count
        sizeW_ <- readIORef sizeW

        GL.clearColor $= GL.Color4 0 0 0 0
        GL.clearDepth $= 1.0

        GL.clear [GL.ColorBuffer,GL.DepthBuffer]

        -- render board
        withTexture GL.Texture3D . GL.preservingMatrix $ do

          -- lights 
          GL.position (GL.Light 0) $= GL.Vertex4 0 0 0 1
          GL.position (GL.Light 1) $= GL.Vertex4 0 0 0 1
          GL.diffuse  (GL.Light 1) $= GL.Color4  1 1 1 1
          GL.specular (GL.Light 1) $= GL.Color4  1 1 1 1

          color3 (0.8,0.5,0.3)
          GL.lineWidth $= 1.0
          GL.renderPrimitive GL.Quads $ do
            mapM_ vertex3 $ square (boardWidth)

          translate3 (0,0,boardWidth*1.5)

            -- mapM_ normal3 $ replicate 3 (0,0,1)

          (rtx,rty) <- readIORef posR
          m         <- readIORef posS
          GL.Position pcx pcy <- GL.get GLFW.mousePos

          -- putStrLn $ "mouse pos sub =" ++ show ( fromIntegral (rtx-cx),fromIntegral (rty-cy))

          let ps = pointToStonePos sizeW_ (rtx,rty) (pcx,pcy)
          putStrLn $ "mouse pos M for stone pos =" ++ show ps
          rotate3 (fromIntegral rty) (1,0,0)
          rotate3 (fromIntegral rtx) (0,1,0)

          -- surface
          color3 (0.2,0.5,0.2)
          GL.lineWidth $= 1.0
          GL.renderPrimitive GL.Quads $ do
            let vBoard = square (boardWidth/2)
            mapM_ vertex3 $ vBoard
            mapM_ (vertex3 . withZ (-1)) . reverse $ vBoard
            -- mapM_ normal3 $ replicate 3 (0,0,1)
         
          GL.preservingMatrix $ do
            color3 (0,0,0)
            translate3 (0,0,1)

            -- outer border
            GL.lineWidth $= 5.0
            GL.preservingMatrix . replicateM_ 4 $ do
              GL.renderPrimitive GL.Lines $ do
                vertex3 (inner, inner,0)
                vertex3 (inner,-inner,0)
              rotate3 90 (0,0,1)

            -- inner border
            GL.lineWidth $= 1.0
            GL.preservingMatrix $ do
              replicateM_ 2 $ do
                let ls = [ (st * fromIntegral x) | x <- [ 1 .. ((size . table $ initState)-1) ] ]
                GL.renderPrimitive GL.Lines . forM_ ls $ \p -> do
                  vertex3 (p-inner,-inner,0)
                  vertex3 (p-inner,inner,0)

                rotate3 90 (0,0,1)

          -- 4 points
          GL.preservingMatrix $ do
            let n = st*(sz-4)/2
            GL.lineWidth $= 1.0
            replicateM_ 4 $ do
              GL.preservingMatrix $ do
                translate3 (n,n,0)
                GL.renderPrimitive GL.Polygon .
                  mapM_ vertex3 $ circleVertices (st*0.075)
              rotate3 90 (0,0,1)

          -- Stones
          GL.preservingMatrix $ do
            let thickness = (st)
            translate3 (0,0,thickness/2)
            renderStones (0.35*st) thickness state_

          GL.preservingMatrix $ do
            color3 (0,1,1)
            let (mpx,mpy) = normWinPos sizeW_ (pcx,pcy)
            translate3 (mpx,mpy,10)
            GL.renderPrimitive GL.Polygon .
              mapM_ vertex3 $ circleVertices (st*0.1)
            translate3 (100,0,0)
            textOut $ show (mpx,mpy)

          color3 (1,0,1)
          translate3 (0,0,1)
          textOut $ "Test! count = " ++ show count_
          translate3 (0,-50,0)
          textOut $ "StonePos =" ++ show ps
          translate3 (-100,-20,0)
          forM_ (stones . table $ state_) $ \s -> do
            translate3 (0,-12,0)
            textOut $ show s


          -- renderStoneBlackWhite (0.35*st) ((0.1)*st) [(1,0,0),(0,0,1)]

        atomicModifyIORef count (\x -> (x + 1, ()))

        -- color3 1 1 1
        -- GL.rasterPos (GL.Vertex3 wy 0 -1)
        -- GL.print (show c)
        -- GL.flush


  let loop = do
        GLFW.waitEvents

        d <- readIORef dirty
        when d $ do 
          atomicModifyIORef count     (\x -> (x + 1, ()))
          atomicModifyIORef gameState (\x -> (looper 0.0 x, ()))
          -- l <- readIORef lines
          GL.clear [GL.ColorBuffer]
          render
          -- color3 1 1 1
          -- GL.rasterPos (GL.Vertex3 wy 0 -1)
          -- GL.print (show c)
          GLFW.swapBuffers

        atomicWriteIORef dirty False

        -- check if we need to quit the loop
        q <- readIORef quit
        when (not q) loop


  let waitForPress = do
        GLFW.mousePosCallback $= \x -> do
          atomicWriteIORef dirty True
          return ()

        GLFW.mouseButtonCallback $= \b s -> do
          when (b == GLFW.ButtonLeft && s == GLFW.Press) $ do
            -- when left mouse button is pressed, add the point
            -- to lines and switch to waitForRelease action.
            GL.Position x y <- GL.get GLFW.mousePos 
            posR_  <- readIORef posR
            sizeW_ <- readIORef sizeW


            atomicWriteIORef posP (x,y)
            atomicWriteIORef posS $ pointToStonePos posR_ sizeW_ (x,y)
            waitForRelease 

      waitForRelease = do
        GLFW.mousePosCallback $= \(GL.Position x y) -> do
          -- mark screen dirty
          GL.Position pcx pcy <- GL.get GLFW.mousePos
          (px,py)             <- atomicModifyIORef posP $ \m -> ((pcx,pcy),m) 
          atomicModifyIORef posR $ \(x,y) ->
            ((x+(px-pcx),y+(py-pcy)),())
          atomicWriteIORef dirty True

        GLFW.mouseButtonCallback $= \b s ->
          -- when left mouse button is released, switch back to
          -- waitForPress action.
          when (b == GLFW.ButtonLeft && s == GLFW.Release) $ do
            (GL.Position cx cy) <- GL.get GLFW.mousePos

            state_ <- readIORef gameState
            sizeW_ <- readIORef sizeW
            prePos <- readIORef posS
            posR_  <- readIORef posR

            -- set rotate
            atomicWriteIORef dirty True

            maybe (return ()) (atomicWriteIORef gameState) $ do
              let die x y = x y Nothing
              m <- prePos
              c <- pointToStonePos sizeW_ posR_ (cx,cy)
              die unless ( c == m && isPlayer state_ && (elem c $ movables state_)  )
              return state_ {
                  step = 0
                , skipped  = False
                , finished = False
                , players  = nextPlayers (players state_)
                , table    = makeMove state_ c
              }

          {--
          when (b == GLFW.ButtonLeft && s == GLFW.Release) $ do
            (px,py) <- readIORef posS
            (GL.Position cx cy) <- GL.get GLFW.mousePos

            state_ <- readIORef gameState
            sizeW_ <- readIORef sizeW

            -- set rotate
            atomicWriteIORef dirty True

            let cs = stonePos $ normWinPos sizeW_ (cx,cy)
            when (cs == stonePos (normWinPos sizeW_ (px,py)) && isPlayer state_) $ do
              case cs of 
                Nothing  -> return ()
                Just ccs -> when (not . null . filter (== ccs) $ movables state_)  $ do
                  atomicWriteIORef gameState $ state_ {
                      step = 0
                    , skipped  = False
                    , finished = False
                    , players  = nextPlayers (players state_)
                    , table    = makeMove state_ ccs
                  }


            --}

            waitForPress

  -- by default start with waitForPress
  waitForPress
  loop

  -- finish up
  FTGL.destroyFont font
  GLFW.closeWindow 
  GLFW.terminate
  -- let stones = stones . table $ state

