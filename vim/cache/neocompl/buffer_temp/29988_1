{-# LANGUAGE GADTs, FlexibleInstances, FlexibleContexts, UndecidableInstances #-}

import Control.Concurrent
import Control.Monad

data Knob = Turned | Unturned
  deriving (Eq,Show)

data OrdinaryDoor = Opened Knob | Closed Knob
  deriving (Eq,Show)

class Door a where
  isOpen, isClose, canBeOpened     :: MVar a -> IO Bool
  pull, push, knobTurn, knobUnturn :: MVar a -> IO ()

  isClose md = isOpen md >>= return . not

instance Door OrdinaryDoor where
  isOpen md = withMVar md $ \x -> return $ case x of
      Opened _ -> True
      _        -> False

  canBeOpened md = withMVar md $ \x -> return $ case x of
      Closed Turned   -> True
      Closed Unturned -> False
      Opened _        -> False

  pull md = modifyMVar_ md $ \_ -> return (Closed Unturned)
  push md = modifyMVar_ md $ \x -> return $ case x of
      Closed Turned -> Opened Unturned
      _             -> x

  knobTurn md = modifyMVar_ md $ \x -> return $ case x of 
    Closed Unturned -> Closed Turned
    Opened Unturned -> Opened Turned
    _               -> x

  knobUnturn md = modifyMVar_ md $ \x -> return $ case x of 
    Closed Turned -> Closed Unturned
    _             -> x

createDoor :: IO (MVar OrdinaryDoor)
createDoor = newMVar $ Closed Unturned

test1 = do
  door <- createDoor

  putStrLn "door is a Door"

  knobTurn door
  canBeOpened door
    >>= putStrLn . ("knobTurn door; canBeOpened door => " ++) . show

  knobUnturn door
  canBeOpened door
    >>= putStrLn . ("knobUnturn door; canBeOpened door => " ++) . show

  push door
  isOpen door
    >>= putStrLn . ("push door; isOpen door => " ++) . show

  knobTurn door
  push door
  isOpen door
    >>= putStrLn . ("knobTurn door; push door; isOpen door => " ++) . show

  pull door
  isOpen door
    >>= putStrLn . ("push door; isOpen door => " ++) . show

  canBeOpened door
    >>= putStrLn . ("canBeOpened door => " ++) . show
 

data WithCloser a where
  WithCloser :: Door a => Int -> MVar () -> MVar a -> WithCloser a

instance (Door a) => Door (WithCloser a) where
  isOpen      = callParentC isOpen
  canBeOpened = callParentC canBeOpened
  pull        = callParentC pull
  knobUnturn  = callParentC knobUnturn
  knobTurn    = callParentC knobTurn

  push md = modifyMVar_ md $ \(WithCloser n m md')-> do
    _ <- tryPutMVar m ()
    m' <- newEmptyMVar
    _ <- forkIO $ do
      threadDelay (n*1000000)
      t <- tryTakeMVar m'
      maybe (pull md) (return) t
    push md'

    return (WithCloser n m' md')

callParentC :: (Door a) => ((MVar a) -> IO b) -> MVar (WithCloser a) -> IO b
callParentC f a = withMVar a ( \(WithCloser _ _ d) -> f d )

withCloser :: (Door a) => Int -> MVar a -> IO (MVar (WithCloser a))
withCloser n md = do
  m     <- newEmptyMVar
  newMVar $ WithCloser n m md

createDoorWithCloser :: Int -> IO (MVar (WithCloser OrdinaryDoor))
createDoorWithCloser n = createDoor >>= withCloser n

test2 = do
  door <- createDoorWithCloser 2

  putStrLn "door is a DoorWithCloser"

  knobTurn door
  push door

  isOpen door
    >>= putStrLn . ("knobTurn door; push door; isOpen door => " ++) . show

  putStrLn "1 second after"
  threadDelay (1*1000*1000)

  isOpen door >>= putStrLn . ("isOpen door => " ++) . show

  putStrLn "3 second after"
  threadDelay (2*1000*1000)
  isOpen door
    >>= putStrLn . ("isOpen door => " ++) . show

data WithStopper a where
  WithStopper :: (Door a) => Bool -> (MVar a) -> WithStopper a

instance (Door a, Stoppered (WithStopper a)) => Door (WithStopper a) where
  isOpen      = callParentS isOpen
  canBeOpened = callParentS canBeOpened
  knobUnturn  = callParentS knobUnturn
  knobTurn    = callParentS knobTurn

  pull md     = do stop <- isStoppered md
                   unless stop $ callParentS pull md

  push md     = do beStopperedOff md
                   callParentS push md

callParentS :: (Door a) => ((MVar a) -> IO b) -> MVar (WithStopper a) -> IO b
callParentS f a = withMVar a ( \(WithStopper _ d) -> f d )

beStoppered :: Bool -> MVar (WithStopper a) -> IO ()
beStoppered b md =
  modifyMVar_ md $ (\(WithStopper _ md') -> return $ WithStopper b md')

class Stoppered a where
  beStopperedOn  :: MVar a -> IO ()
  beStopperedOff :: MVar a -> IO ()
  isStoppered    :: MVar a -> IO Bool

instance Stoppered (WithStopper OrdinaryDoor) where
  beStopperedOn  = beStoppered True
  beStopperedOff = beStoppered False
  isStoppered md = withMVar md $ \(WithStopper b _) -> return b

instance Stoppered (WithCloser (WithStopper OrdinaryDoor)) where
  beStopperedOn  = callParentC beStopperedOn
  isStoppered    = callParentC isStoppered
  beStopperedOff md = do callParentC beStopperedOff md
                         push md

withStopper :: (Door a) => Bool -> MVar a -> IO (MVar (WithStopper a))
withStopper state = newMVar . WithStopper state 

createDoorWithStopper :: IO (MVar (WithStopper OrdinaryDoor))
createDoorWithStopper = createDoor >>= withStopper False

test3 = do 
  door <- createDoorWithStopper

  putStrLn "door is a DoorWithStopper"

  knobTurn door
  push door

  isOpen door
    >>= putStrLn . ("knobTurn door; push door; isOpen door => " ++) . show

  beStopperedOn door
  pull door

  isOpen door
    >>= putStrLn . ("beStopperedOn door; pull door; isClose door => " ++) . show

  beStopperedOff door
  pull door

  isOpen door
    >>= putStrLn . ("beStopperedOff door; pull door; isClose door => " ++) . show
 
createDoorWithStopperCloser :: Int -> IO (MVar (WithCloser (WithStopper OrdinaryDoor)))
createDoorWithStopperCloser n =
  createDoorWithStopper >>= withCloser n

test4 = do
  door <- createDoorWithStopperCloser 3

  putStrLn "door is a DoorWithStopperCloser"

  knobTurn door
  push door
  isOpen door
    >>= putStrLn . ("knobTurn door; push door; isOpen door => " ++) . show

  beStopperedOn door

  putStrLn "beStopperedOn door; then 4 seconds after"
  threadDelay (4*1000*1000)

  isClose door >>= putStrLn . ("isClose door => " ++) . show

  beStopperedOff door

  putStrLn "beStopperedOff door; then 4 seconds after"
  threadDelay (4*1000*1000)

  isClose door
    >>= putStrLn . ("isClose door => " ++) . show

  knobTurn door
  push door

  isOpen door
    >>= putStrLn . ("knobTurn door; push door; isOpen door => " ++) . show

  beStopperedOn door

  putStrLn "beStopperedOn door; then 4 seconds after"
  threadDelay (4*1000*1000)

  isClose door
    >>= putStrLn . ("isClose door => " ++) . show

  push door

  putStrLn "pudh door; then 4 seconds after"

  threadDelay (4*1000*1000)

  isClose door
    >>= putStrLn . ("isClose door => " ++) . show

main, test1, test2, test3, test4  :: IO ()
main = mapM_ id [test1,test2,test3,test4]
 
