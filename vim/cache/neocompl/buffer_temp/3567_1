{-# LANGUAGE OverloadedStrings, PackageImports #-}
module Othello.Renderer.GLFW(play) where

-- import Graphics.UI.GLFW as GLFW
-- import qualified "GLFW-b" Graphics.UI.GLFW as GLFWb
-- import Graphics.GL as RawGL
import qualified "GLFW" Graphics.UI.GLFW as GLFW
import qualified Graphics.Rendering.OpenGL as GL
import qualified Graphics.Rendering.FTGL as FTGL
import Foreign.Marshal.Alloc(alloca)
import Graphics.Rendering.OpenGL (($=))
import Control.Monad (forM_, mapM_, replicateM_, when)
import Data.IORef(newIORef, readIORef, atomicModifyIORef, atomicWriteIORef)

import Othello.Core
import Othello.Game

loadFont fontPath fontSize renderResolution =  do
  font <- FTGL.createPolygonFont fontPath
  FTGL.setFontFaceSize font fontSize renderResolution
  return font

play :: Play
play looper initState = do

  -- main resolution
  let (xres,yres) = windowSize initState
      (rx,ry)     = (fromIntegral xres, fromIntegral yres) :: (Float,Float)
      (near,far)  = (10,100) :: (Float,Float)

  font <- loadFont "MTLmr3m.ttf" (floor $ rx/120) (floor rx)

  GLFW.initialize

  -- enable antialiasing (especially for fonts)
  GLFW.openWindowHint GLFW.FSAASamples 4

  GLFW.openWindow (GL.Size (fromIntegral xres) (fromIntegral yres)) [GLFW.DisplayAlphaBits 8] GLFW.Window
  GLFW.windowTitle $= "Hothello"

  -- multisample is enabled as opengl default.
  -- GL.multisample $= GL.Enabled

  GL.lineSmooth $= GL.Enabled
  GL.blend      $= GL.Enabled
  GL.blendFunc  $= (GL.SrcAlpha, GL.OneMinusSrcAlpha)
  GL.clearColor $= GL.Color4 0 0 0 0

  -- disable auto polling in swapBuffers
  GLFW.disableSpecial GLFW.AutoPollEvent

  -- state vars
  state <- newIORef initState
  dirty <- newIORef True
  quit  <- newIORef False
  posM  <- newIORef (GL.Position 0 0)
  sizeW <- newIORef (GL.Size 0 0)
  scale <- newIORef (0.0 :: Float)
  count <- newIORef 0

  -- onResize (and onOpen)
  GLFW.windowSizeCallback $= \ size@(GL.Size w h) -> do
    -- compute target scale for viewport to fit direction and size appropriately.
    let (rw,rh) = tmap fromIntegral (w,h) :: (Float,Float)
        scale_  = min (rw/rx) (rh/ry)
        scaling = (/ (2 * scale_)) 
        (fw,fh) = tmap (realToFrac . scaling)    (rw,rh)
        (zn,zf) = tmap (realToFrac . (/ scale_)) (near,far)

    atomicWriteIORef scale scale_
    atomicWriteIORef sizeW size

    GL.viewport   $= (GL.Position 0 0, size)

    GL.matrixMode $= GL.Projection
    GL.loadIdentity
    GL.frustum (-fw) fw (-fh) fh zn zf -- centering

    GL.matrixMode $= GL.Modelview 0
    GL.loadIdentity

  GLFW.windowRefreshCallback $= atomicWriteIORef dirty True
  GLFW.windowCloseCallback   $= do
    atomicWriteIORef quit True
    return True

  -- use key callback to track whether ESC or Q is pressed
  GLFW.keyCallback $= \key st -> do
    when (key == GLFW.SpecialKey GLFW.ESC && st == GLFW.Press) $ do
      atomicWriteIORef quit True

    when (key == GLFW.CharKey 'Q' && st == GLFW.Press) $ do
      atomicWriteIORef quit True

  let sq m        = [(-m,-m,0),(m,-m,0),(m,m,0),(m,-m,0)]
      boardWidth = rx * 0.8
      margin     = 0.01 * boardWidth
      padding    = 0.03 * boardWidth
      inner      = (boardWidth/2) - padding
      sz         = fromIntegral . size . table $ initState
      st         = 2 * inner  / sz

      normWinPos p = do
        (GL.Size x y) <- readIORef sizeW
        scale_        <- readIORef scale
        let (px,py) = tmap fromIntegral p
    l       (sx,sy) = tmap fromIntegral (x,y)
            (cx,cy) = (px - sx/2,py - sy/2) -- centering
        return $ tmap (/scale_) (cx,cy) -- normalize
        
      stonePos (x,y) = do
        (tx,ty) <- normWinPos (x,y)
        if (abs tx <= inner && abs ty <= inner)
        then return . Just . tmap (floor . (/ st) . (+ inner)) $ (tx,ty)
        else return Nothing

      transXY m (x,y,z) = (x + m, y + m, z)
      withZ z (x,y,_) = (x,y,z)
      -- uncurry3 f (a,b,c) = f a b c
      color3     (a,b,c) = GL.color     (GL.Color3  a b c :: GL.Color3  GL.GLfloat)
      vertex3    (a,b,c) = GL.vertex    (GL.Vertex3 a b c :: GL.Vertex3 GL.GLfloat)
      translate3 (a,b,c) = GL.translate (GL.Vector3 a b c :: GL.Vector3 GL.GLfloat)
      rotate3 d  (a,b,c) = GL.rotate d  (GL.Vector3 a b c :: GL.Vector3 GL.GLfloat)

      -- xyFaceCircle :: Float -> (Float,Float,Float) -> [(Float,Float,Float)]
      xyFaceCircle r = mapM_  vertex3 $ circleVertices r
      circleVertices r = [ (r*cos t,r*sin t,0) | t <- [0,0.2..(2*pi)] ]

  let renderStoneBlackWhite radius thickness state_ = do
        let z      = thickness/2
            vsBase = circleVertices radius
            vsTop  = map (withZ z) vsBase
            vsSide = vsBase ++ reverse vsTop

        -- (color -> face -> side)
        forM_ [(0,0,0),(1,1,1)] $ \cl -> do
          color3 cl
          GL.renderPrimitive GL.Polygon $ mapM_ vertex3 vsTop
          GL.renderPrimitive GL.Polygon $ mapM_ vertex3 vsSide
          rotate3 180 (1,0,0)


      -- positions :: (StoneColor,Position) -> (Float,Float)

      stonesOf :: StoneColor -> GameState -> [(Float,Float)]
      stonesOf stoneColor state_ = map positions . filter byColor . stones . table $ state_
          where positions (_,  pos) = tmap fromIntegral pos
                byColor   (color,_) = (color == stoneColor)

      renderStones :: StoneColor -> Float -> Float -> GameState -> IO ()
      renderStones color radius thickness state_ =
        GL.preservingMatrix $ do
          when (color == White) $ do
            rotate3 180 (1,0,0)

          translate3 (-inner,-inner,thickness/2)

          forM_ (stonesOf color state_) $ \(sx,sy) -> do
            GL.preservingMatrix $ do
              translate3 (((sx + 0.5) * st),((sy + 0.5) * st),0)
              -- mapM_ (renderStone . trans (-inner,0z) . tmap ((+ st/2) . (* st))) . stonesOf
              -- GL.translate ((sx + 0.5) * st) Vector3 (-inner) (-inner) (thickness / 2) :: Vector3 GL.GLfloat)
              renderStoneBlackWhite radius thickness state_

  let render = do
        state_ <- readIORef state
        count_ <- readIORef count
        scale_ <- readIORef scale

        -- l <- readIORef lines
        GL.clear [GL.ColorBuffer,GL.DepthBuffer]

        -- lights 
        GL.position (GL.Light 0) $= GL.Vertex4 0 0 0 1
        GL.position (GL.Light 1) $= GL.Vertex4 0 0 0 1
        GL.diffuse  (GL.Light 1) $= GL.Color4  1 1 1 1
        GL.specular (GL.Light 1) $= GL.Color4  1 1 1 1

        -- render board
        GL.preservingMatrix $ do

          -- surface
          color3 (0.2,0.5,0.2)
          GL.lineWidth $= (1.0/scale_)
          translate3 (0,0, (-near)/scale_)

          GL.renderPrimitive GL.Quads $ do
            mapM_ vertex3 $ sq (boardWidth/2)
          -- (\(x,y,z) -> GL.normal (GL.Normal3 x y (z :: GLfloat))) $ sqn (wx,wy,1)
          -- GL.normal (sqn (wx,wy))
         
          -- outer border
          translate3 (0,0,0.01/scale_)
          color3 (0,0,0)
          GL.lineWidth $= (5.0/scale_)
          GL.preservingMatrix . replicateM_ 4 $ do
            GL.renderPrimitive GL.Lines $ do
              vertex3 (inner, inner,0)
              vertex3 (inner,-inner,0)
            rotate3 90 (0,0,1)

          -- inner border
          color3 (0,0,0)
          GL.lineWidth $= (1.0/scale_)
          GL.preservingMatrix $ do
            translate3 (-inner,-inner,0)
            replicateM_ 2 $ do
              let ls = [ (st * fromIntegral x) | x <- [ 1 .. ((size . table $ initState)-1) ] ]
              GL.renderPrimitive GL.Lines . forM_ ls $ \p -> do
                vertex3 (p,0,0)
                vertex3 (p,2*inner,0)

            rotate3 90 (0,0,1)

          -- 4 points
          GL.preservingMatrix $ do
            let n = st*(sz-2)
            replicateM_ 4 . GL.preservingMatrix $ do
              translate3 (n,n,0)
              GL.renderPrimitive GL.Polygon .
                mapM_ vertex3 $ circleVertices (4/scale_)
              rotate3 90 (0,0,1)

          -- Sones
          forM_ [White,Black] $ \color ->
            renderStones color (0.35*st) (6/scale_) state_

        GL.preservingMatrix $ do
          color3 (1,1,1)
          translate3 (0,0,-near)
          FTGL.renderFont font ("Test! : " ++ show count_) (FTGL.All :: FTGL.RenderMode)

        atomicModifyIORef count (\x -> (x + 1, ()))

        -- color3 1 1 1
        -- GL.rasterPos (GL.Vertex3 wy 0 -1)
        -- GL.print (show c)
        -- GL.flush
        GLFW.swapBuffers

  let loop = do
        GLFW.waitEvents

        d <- readIORef dirty
        when d $ do 
          atomicModifyIORef count (\x -> (x + 1, ()))
          atomicModifyIORef state (\x -> (looper 0.0 x, ()))
          -- l <- readIORef lines
          GL.clear [GL.ColorBuffer]
          render
          -- color3 1 1 1
          -- GL.rasterPos (GL.Vertex3 wy 0 -1)
          -- GL.print (show c)
          GLFW.swapBuffers

        atomicWriteIORef dirty False

        -- check if we need to quit the loop
        q <- readIORef quit
        when (not q) loop

  let waitForPress = do
        GLFW.mousePosCallback    $= \_   -> return ()
        GLFW.mouseButtonCallback $= \b s -> do
          when (b == GLFW.ButtonLeft && s == GLFW.Press) $ do
            -- when left mouse button is pressed, add the point
            -- to lines and switch to waitForRelease action.
            GL.get GLFW.mousePos >>= atomicWriteIORef posM
            waitForRelease 

      waitForRelease = do
        GLFW.mousePosCallback $= \(GL.Position x y) -> do
          -- mark screen dirty
          atomicWriteIORef dirty True

        GLFW.mouseButtonCallback $= \b s ->
          -- when left mouse button is released, switch back to
          -- waitForPress action.
          when (b == GLFW.ButtonLeft && s == GLFW.Release) $ do
            (GL.Position px py) <- readIORef posM
            (GL.Position cx cy) <- GL.get GLFW.mousePos

            state_ <- readIORef state

            cs <- stonePos (cx,cy)
            ps <- stonePos (px,py)
            let ms = movables state_

            when (cs == ps && isPlayer state_) $ do
              case cs of 
                Nothing  -> return ()
                Just ccs -> when ((not . null $ ms) && elem ccs ms) $ do
                  atomicWriteIORef state $ state_ {
                      step = 0
                    , skipped  = False
                    , finished = False
                    , players  = nextPlayers (players state_)
                    , table    = makeMove state_ ccs
                  }

            waitForPress

  -- by default start with waitForPress
  waitForPress
  loop

  -- finish up
  FTGL.destroyFont font
  GLFW.closeWindow 
  GLFW.terminate
  -- let stones = stones . table $ state

